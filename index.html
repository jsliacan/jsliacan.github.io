---
layout: default
use_math: true
---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$']]}
});
</script>
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<br />
<br />

<div class="home" id="container">

  <!--
     <img align="right" width="20%" hspace="200" src={{site.url}}/assets/profile_pic.jpg>
     -->
  <h2> About </h2>

  <p>
    I am a researcher at VTI - Swedish National Road and Transport Research Institute.
  </p>

  <br />
  <br />


  <h2> Preprints </h2>
  <p style="color:#454647">(click on arrows to expand, on title to go to arxiv)</p>

  <p>
    <details style="color:#55708E">
      <summary style="color:#000000">J. Sliačan, and M. Cíbik<a href="https://osf.io/preprints/socarxiv/pbgnx_v1"> Systemic motonormativity</a></summary>
      <p>
        While motonormativity has been talked about in the transport circles for a long time, a detailed account that would make the concept suitable for deeper analysis was mostly lacking. To change that, Walker, Davis, Tapp (2023) define the concept as a "cultural inability to think objectively and dispassionately due to largely unconscious assumptions about how travel is", and then attempt to establish its presence experimentally. In this paper, we argue that while the concept of motonormativity is very important, Walker’s et al. and similar approaches to motonormativity contain serious problems that need to be rectified.
      </p>
      <p>
        The first part of the paper spells out in detail where gaps exist in the current understanding of motonormativity. First, the "bias" understanding of motonormativity assumes an implausible form of moral objectivism, stipulating an "unbiased" baseline of judgement as a vantage point. Second, the definitions put forward are distinctly individualistic (as opposed to systemic), missing the opportunity to address the aspects of motonormativity that are not reducible to individual beliefs. The second part of the paper then presents a more comprehensive take on motonormativity as a hierarchy entrenched in the transport system and positions it as a system-level phenomenon that can be understood outside of the constrains of individual beliefs and actions.
        <a href="https://osf.io/preprints/socarxiv/pbgnx_v1">[SocArXiv:pbgnx_v1]</a>
      </p>
    </details>
  </p>
  
  <p>
    <details style="color:#55708E">
      <summary style="color:#000000">J. Sliačan, and K. Kircher<a href="{{site.url}}/assets/anomaly.pdf"> Anomaly detetion as modularity-based community detection</a></summary>
      <p>
        When measuring how drivers overtake cyclists, one of the underlying problems is extracting the overtaking event from a time series of lateral distance readings. This note aims to describe a simple approach that seems effective in applications like ours. It consists of carefully transforming our problem into a network problem, then leveraging a community detection algorithm to extract subsequence candidates. Lastly, we choose the anomalous subsequence from the set of returned subsequences. To the best of our knowledge, this approach to anomaly detection does not appear in the literature even though it is intuitive, offers a fair amount of control, and is not computationally expensive. Our goal is to present the crux of the method with clarity and identify where more effort could improve it. We demonstrate our approach with modularity-based community detection and point out a shared nature of our approach with density-based cluster detection methods.
        <a href="{{site.url}}/assets/anomaly.pdf">[anomaly.pdf]</a>
      </p>
    </details>
  </p>

  <br />
  <br />
  
  <h2> Published </h2>
  <!-- <p style="color:#454647">(click on arrows to expand, on title to go to arxiv)</p> -->

  <p>
    <details style="color:#55708E">
      <summary style="color:#000000">R. Brignall, and J. Sliačan <a href="https://arxiv.org/abs/1902.02705">Combinatorial specifications for juxtapositions of permutation classes</a>. <i>Electronic Journal of Combinatorics</i>, 26(4). 2019</summary>
      <p>
        We show that, given a suitable combinatorial specification for a permutation class $\mathcal{C}$, one can obtain a specification for the juxtaposition (on either side) of $\mathcal{C}$ with Av(21) or Av(12), and that if the enumeration for $\mathcal{C}$ is given by a rational or algebraic generating function, so is the enumeration for the juxtaposition. Furthermore this process can be iterated, thereby providing an effective method to enumerate any 'skinny' $k\times 1$ grid class in which at most one cell is non-monotone, with a guarantee on the nature of the enumeration given the nature of the enumeration of the non-monotone cell. 
        <a href="https://arxiv.org/abs/1902.02705">[arXiv:1902.02705]</a>
      </p>
    </details>
  </p>

  <p>
    <details style="color:#55708E">
      <summary style="color:#000000">O. Pikhurko, J. Sliačan, and K. Tyros. <a href="https://arxiv.org/abs/1706.02612">Strong Forms of stability from flag algebra calculations</a>. <i>Journal of Combinatorial Theory, Series B, Vol. 135, 2019.</i>
      </summary>
        <p>
          Given a hereditary family $\mathcal{G}$ of admissible graphs and a function $\lambda(G)$ that linearly depends on the statistics of order-$\kappa$ subgraphs in a graph $G$, we consider the extremal problem of determining $\lambda(n,\mathcal{G})$, the maximum of $\lambda(G)$ over all admissible graphs $G$ of order $n$. We call the problem perfectly $B$-stable for a graph $B$ if there is a constant $C$ such that every admissible graph $G$ of order $n\geq C$ can be made into a blow-up of $B$ by changing at most $C(\lambda(n,\mathcal{G})−\lambda(G))\binom{n}{2}$ adjacencies. As special cases, this property describes all almost extremal graphs of order $n$ within $o(n^2)$ edges and shows that every extremal graph of order $n\geq n_0$ is a blow-up of $B$.
        </p>

        <p>
          We develop general methods for establishing stability-type results from flag algebra computations and apply them to concrete examples. In fact, one of our sufficient conditions for perfect stability is stated in a way that allows automatic verification by a computer. This gives a unifying way to obtain computer-assisted proofs of many new results. 
          <a href="https://arxiv.org/abs/1706.02612">[arXiv:1706.02612]</a>
        </p>
    </details>
  </p>

  <p>
    <details style="color:#55708E">
      <summary style="color:#000000">J. Sliačan, and W. Stromquist. <a href="https://arxiv.org/abs/1704.02959">Improving bounds on packing densities of 4-point permutations</a>. <i>DMTCS</i>, 19(2). 2018. Permutation Patterns 2016
      </summary>
      <p>
        We consolidate what is currently known about packing densities of 4-point permutations and in the process improve current lower bounds for the packing densities of 1324 and 1342. We also provide rigorous upper bounds for the packing densities of 1324, 1342, and 2413. All our bounds are within $10^{−4}$ of the true packing densities. Together with the known bounds, this gives us a fairly complete picture of all 4-point packing densities. We also provide new upper bounds for several small permutations of length at least five. Our main tool for the upper bounds is the framework of flag algebras introduced by Razborov in 2007. 
        <a href="https://arxiv.org/abs/1704.02959">[arXiv:1704.02959]</a>
      </p>
    </details>
  </p>


  <p>
    <details style="color:#55708E">
      <summary style="color:#000000">R. Brignall, and J. Sliačan. <a href="https://arxiv.org/abs/1611.05370">Juxtaposing Catalan permutation classes with monotone ones</a>. <i>Electronic Journal of Combinatorics</i>, 24(2). 2017
      </summary>
      <p>
        This paper enumerates all juxtaposition classes of the form "$Av(abc)$ next to $Av(xy)$", where $abc$ is a permutation of length three and $xy$ is a permutation of length two. We use Dyck paths decorated by sequences of points to represent elements from such a juxtaposition class. Context-free grammars are then used to enumerate these decorated Dyck paths. 
        <a href="https://arxiv.org/abs/1611.05370">[arXiv:1302.4216]</a>
      </p>
    </details>
  </p>

  <p>
    <details style="color:#55708E">
      <summary style="color:#000000">K. Bringmann, B. Doerr, A. Neumann, and J. Sliačan. <a href="http://arxiv.org/abs/1302.4216">Online checkpointing with improved worst-case guarantees</a>. <i>INFORMS Journal on Computing</i>, 27(3): 478-490. 2015
      </summary>
      <p>
        In the online checkpointing problem, the task is to continuously maintain a set of $k$ checkpoints that allow to rewind an ongoing computation faster than by a full restart. The only operation allowed is to replace an old checkpoint by the current state. Our aim are checkpoint placement strategies that minimize rewinding cost, i.e., such that at all times $T$ when requested to rewind to some time $t \leq T$ the number of computation steps that need to be redone to get to $t$ from a checkpoint before $t$ is as small as possible. In particular, we want that the closest checkpoint earlier than $t$ is not further away from $t$ than $q_k$ times the ideal distance $T / (k+1)$, where $q_k$ is a small constant. Improving over earlier work showing $1 + 1/k \leq q_k \leq 2$, we show that $q_k$ can be chosen asymptotically less than $2$. We present algorithms with asymptotic discrepancy $q_k \leq 1.59 + o(1)$ valid for all k and $q_k \leq \ln(4) + o(1) \leq 1.39 + o(1)$ valid for k being a power of two. Experiments indicate the uniform bound $p_k \leq 1.7$ for all $k$. For small $k$, we show how to use a linear programming approach to compute good checkpointing algorithms. This gives discrepancies of less than $1.55$ for all $k \lt 60$. We prove the first lower bound that is asymptotically more than one, namely $q_k \geq 1.30 - o(1)$. We also show that optimal algorithms (yielding the infimum discrepancy) exist for all $k$. 
        <a href="http://arxiv.org/abs/1302.4216">[arXiv:1302.4216]</a>
      </p>
    </details>
  </p>

  <!--
  <br/>
  <br/>
  <br/>
  
  <h2>Posts</h2> 
  <ul class="post-list">
    {% for post in site.posts %}
    <li>
      <span class="post-meta">{{ post.date | date: "%b %-d, %Y" }}</span>
      
      <h1>
        <a class="post-link" href="{{ post.url | prepend: site.baseurl }}">{{ post.title }}</a>
      </h1>
    </li>
    {% endfor %}
  </ul>
  -->
</div>
